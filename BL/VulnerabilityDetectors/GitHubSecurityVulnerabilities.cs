using GraphQL;
using GraphQL.Client.Abstractions;
using Microsoft.Extensions.Logging;
using System;
using System.Linq;
using System.Threading.Tasks;
using VulnerabilityDetector.BL.Exceptions;
using VulnerabilityDetector.Interfaces;
using VulnerabilityDetector.Models;

namespace VulnerabilityDetector.BL
{
    public class GitHubSecurityVulnerabilities : IVulnerabilityDetecter
    {
        private readonly IGraphQLClient _client;
        private readonly ILogger _logger;

        public GitHubSecurityVulnerabilities(IGraphQLClient client, ILogger<GitHubSecurityVulnerabilities> logger)
        {
            _client = client;
            _logger = logger;
        }

        public async Task<VulnerablePackage> DetectVulnerablePackageAsync(string package, Version usagedVersion)
        {
            string query = PrepareQuery(package);
            GraphQLResponse<GitHubSecurityVulnerabilitiesResponse> response = await _client.SendQueryAsync<GitHubSecurityVulnerabilitiesResponse>(query);

            ValidateResponse(response);

            foreach (Node item in response.Data.SecurityVulnerabilities.Nodes)
            {
                string verRange = item.VulnerableVersionRange;
                if (UsagedVersionInRange(verRange, usagedVersion)) 
                {
                    return new VulnerablePackage()
                    {
                        Name = item.Package.Name,
                        Severity = item.Severity,
                        Version = usagedVersion.ToString(),
                        FirstPatchedVersion = item.FirstPatchedVersion.Identifier
                    };
                }
            }

            return null;
        }

        private string PrepareQuery(string package)
        {
            string queryTemplate = @"
{{
    securityVulnerabilities(ecosystem: NPM, first: 100, package: ""{0}"") {{
    nodes {{
            severity
            package {{
                name
                ecosystem
            }}
            vulnerableVersionRange
            firstPatchedVersion {{
                identifier
                }}
            }}
         }}
}}";
            return string.Format(queryTemplate, package);
        }

        private void ValidateResponse(GraphQLResponse<GitHubSecurityVulnerabilitiesResponse> response)
        {
            if (response != null && response.Errors != null && response.Errors.Any())
            {
                foreach (GraphQLError item in response.Errors)
                {
                    _logger.LogError($"Failed to query {nameof(GitHubSecurityVulnerabilities)}. {item.Message}");
                }

                throw new GraphQLResponseErrorException();
            }
        }

        private bool UsagedVersionInRange(string range, Version usagedVer)
        {
            if (range.Contains(',')) // case - ">= 1.0.0, < 1.0.2"
            {
                string[] splitted = range.Split(",");
                string greaterThanVal = splitted.FirstOrDefault(x => x.Contains(">=")).Trim();
                Version minVer = new Version(greaterThanVal[2..]);
                Version maxVer = new Version(splitted.FirstOrDefault(x => x.Contains("<")).Trim()[1..]);
                return usagedVer >= minVer && usagedVer < maxVer;
            }
            else  // case "< 1.0.2"
            {
                Version maxVer = new Version(range.Trim()[1..]);
                return usagedVer < maxVer;
            }
        }
    }
}
