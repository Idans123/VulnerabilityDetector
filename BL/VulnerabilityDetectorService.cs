using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using VulnerabilityDetector.BL.Exceptions;
using VulnerabilityDetector.BL.Parsers;
using VulnerabilityDetector.Interfaces;
using VulnerabilityDetector.Models;
using VulnerabilityDetector.Utils;

namespace VulnerabilityDetector.BL
{
    public class VulnerabilityDetectorService : IVulnerabilityDetectorService
    {
        private readonly IVulnerabilityDetecter _vulnerabilityDetecter;
        private readonly ILogger _logger;

        private const bool _IgnoreCase = true;

        public VulnerabilityDetectorService(IVulnerabilityDetecter vulnerabilityQuery, ILogger<VulnerabilityDetectorService> logger)
        {
            _vulnerabilityDetecter = vulnerabilityQuery;
            _logger = logger;
        }

        public async Task<VulnerablePackagesResponse> ScanAsync(string ecosystem, string fileContent)
        {
            VulnerablePackagesResponse vulnerablePackagesResponse = new VulnerablePackagesResponse()
            {
                VulnerablePackages = new List<VulnerablePackage>()
            };

            IParser parser = GetParser(ecosystem);

            string decodedContent = DecodeContent(fileContent);

            Dictionary<string, Version> packageToVersionDict = ParsePackages(parser, decodedContent);

            foreach (KeyValuePair<string, Version> kvp in packageToVersionDict)
            {
                VulnerablePackage res = await _vulnerabilityDetecter.DetectVulnerablePackageAsync(kvp.Key, kvp.Value);

                if (res != null)
                {
                    vulnerablePackagesResponse.VulnerablePackages.Add(res);
                }
            }

            return vulnerablePackagesResponse;
        }

        private IParser GetParser(string ecosystem)
        {
            if (!Enum.TryParse<eParserTypes>(ecosystem, _IgnoreCase, out eParserTypes parserType))
            {
                throw new UnsupportedParserException(ecosystem);
            }

            return ParsersFactory.GenerateParser(parserType);
        }

        private string DecodeContent(string fileContent)
        {
            string decoded = DecodedHelper.DecodeFileContent(fileContent);

            _logger.LogInformation($"Content decoded successfully. Content: {decoded}");

            return decoded;
        }

        private Dictionary<string, Version> ParsePackages(IParser parser, string decodedContent)
        {
            Dictionary<string, Version> packageToVersion = parser.Parse(decodedContent);

            LogParsedPackages(packageToVersion);

            return packageToVersion;
        }

        private void LogParsedPackages(Dictionary<string, Version> packageToVersion)
        {
            _logger.LogInformation("The following Packages were parsed:");

            foreach (KeyValuePair<string, Version> kvp in packageToVersion)
            {
                _logger.LogInformation($"Package: { kvp.Key }, Version: { kvp.Value }");
            }
        }
    }
}
